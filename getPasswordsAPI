 # BeyondInsight v22 API Configuration
$serverName = "servername"
$baseUrl = "https://$serverName/BeyondTrust/api/public/v3"

# API Authentication
$apiKey = ""
$runAsUser = "apiuser"
#Likely don't need the user password but depends on BeyondTrust version
#$userPassword = "your-password"

# Skip SSL certificate validation for self-signed certificates
if (-not ([System.Management.Automation.PSTypeName]'ServerCertificateValidationCallback').Type) {
    $certCallback = @"
    using System;
    using System.Net;
    using System.Net.Security;
    using System.Security.Cryptography.X509Certificates;
    public class ServerCertificateValidationCallback
    {
        public static void Ignore()
        {
            if(ServicePointManager.ServerCertificateValidationCallback == null)
            {
                ServicePointManager.ServerCertificateValidationCallback += 
                    delegate
                    (
                        Object obj, 
                        X509Certificate certificate, 
                        X509Chain chain, 
                        SslPolicyErrors errors
                    )
                    {
                        return true;
                    };
            }
        }
    }
"@
    Add-Type $certCallback
}
[ServerCertificateValidationCallback]::Ignore()

# Also set TLS version
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Common headers
$headers = @{
    Authorization = "PS-Auth key=$apiKey; runas=$runAsUser; pwd=[$userPassword];"
    "Content-Type" = "application/json"
}

# CSV output path
$csvPath = Join-Path -Path (Get-Location) -ChildPath "account_passwords.csv"

# Initialize CSV with header so -Append works without errors
[PSCustomObject]@{
    SystemName        = ""
    DomainName        = ""
    AccountName       = ""
    Status            = ""
    RetrievedPassword = ""
    ErrorMessage      = ""
} | Export-Csv -Path $csvPath -NoTypeInformation

try {
    # Sign in
    $signIn = Invoke-RestMethod `
        -Uri "$baseUrl/Auth/SignAppin" `
        -Method Post `
        -Headers $headers `
        -SessionVariable session
    Write-Host "Signed in as $($signIn.Name)" -ForegroundColor Green

    # --- Pagination Setup ---
    $offset = 0
    $limit = 500
    $allAccounts = @()

    do {
        $uri = "$baseUrl/ManagedAccounts?offset=$offset&limit=$limit"
        $accounts = Invoke-RestMethod -Uri $uri -Method Get -Headers $headers -WebSession $session

        if ($accounts -ne $null -and $accounts.Count -gt 0) {
            $allAccounts += $accounts
            Write-Host "Retrieved $($accounts.Count) accounts (offset=$offset)" -ForegroundColor Cyan
            $offset += $limit
        }
        else {
            break
        }
    } while ($true)

    if ($allAccounts.Count -eq 0) {
        Write-Host "No managed accounts found." -ForegroundColor Red
        exit 1
    }

    foreach ($account in $allAccounts) {
        $systemName    = $account.SystemName
        $accountName   = $account.AccountName
        $domainName    = $account.DomainName
        $systemId      = $account.SystemId
        $accountId     = $account.AccountId

        $password = ''
        $errorMsg = ''
        $req = $null

        try {
            # Create password request
            $body = @{
                SystemId        = $systemId
                AccountId       = $accountId
                DurationMinutes = 60
                Reason          = "Automated bulk access"
                ConflictOption  = "reuse"
            } | ConvertTo-Json

            $requestId = Invoke-RestMethod `
                -Uri "$baseUrl/Requests" `
                -Method Post `
                -Headers $headers `
                -WebSession $session `
                -Body $body

            Write-Host "✓ [$systemName] [$domainName] [$accountName] is checked out. Retrieving credentials…" -ForegroundColor Green

            # Fetch the request status
            $allRequests = Invoke-RestMethod `
                -Uri "$baseUrl/Requests" `
                -Method Get `
                -Headers $headers `
                -WebSession $session

            $req = $allRequests | Where-Object { $_.RequestID -eq $requestId }

            if ($null -eq $req) {
                throw "Request $requestId not found."
            }

            if ($req.Status -eq "active") {
                try {
                    # Retrieve password
                    $password = Invoke-RestMethod `
                        -Uri "$baseUrl/Credentials/$requestId" `
                        -Method Get `
                        -Headers $headers `
                        -WebSession $session                        
                }
                catch {
                    if ($_.Exception.Message -match "400") {
                        $errorMsg = "No password available or cannot retrieve credentials for this account."
                        Write-Warning "[$accountName]: $errorMsg"
                    } else {
                        $errorMsg = "Failed to retrieve credentials: $($_.Exception.Message)"
                        Write-Warning "[$accountName]: $errorMsg"
                    }
                }
            }
            else {
                $errorMsg = "Request status is '$($req.Status)' - skipping retrieval."
            }
        }
        catch {
            $errorMsg = $_.Exception.Message
            Write-Warning "Skipping account [$accountName]: $errorMsg"
        }

        # Log result with any errors and retrieved password (if any)
        $output = [PSCustomObject]@{
            SystemName        = $systemName
            DomainName        = $domainName
            AccountName       = $accountName
            Status            = if ($req) { $req.Status } else { "N/A" }
            RetrievedPassword = $password
            ErrorMessage      = $errorMsg
        }
        $output | Export-Csv -Path $csvPath -NoTypeInformation -Append
    }

    # Sign out
    Invoke-RestMethod `
        -Uri "$baseUrl/Auth/Signout" `
        -Method Post `
        -Headers $headers `
        -WebSession $session
    Write-Host "`nSigned out." -ForegroundColor Green
    Write-Host "`nAll results exported to $csvPath" -ForegroundColor Yellow

} catch {
    Write-Host "Fatal error: $($_.Exception.Message)" -ForegroundColor Red
}
 
